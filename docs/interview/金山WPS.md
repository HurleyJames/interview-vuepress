# 金山WPS

1. 怎么判断图的两个节点是否是连通的

    * 深度优先遍历：从根开始深度优先遍历，设置一个全局变量count去记录。如果最终count的值与顶点的数量是相同的，则是连通图，反之则不是。
    * 广度优先遍历
    * 并查集

2. 介绍一下TCP三次握手
3. 类加载的过程，了解双亲委派模型吗

    类加载的全过程分为：「**加载、验证、准备、解析和初始化**」这5个阶段。

    ![类加载的全过程](https://i.loli.net/2021/01/07/ilxgTsyHKdXJ4a3.png)

    类加载器的作用是将编译器编译生成的二进制.class文件加载到内存中，进而转化成虚拟机中的类。Java内置了三种类加载器：

    * 启动类加载器 Bootstrap Class Loader：负责Java核心类
    * 扩展类加载器 Extensions Class Loader：负责加载`\jre\lib\ext`目录下的JAR包
    * 系统类加载器 System Class Loader：负责加载所有应用程序级别的类到JVM

    除此之外，还可以自定义类加载器。

    ---

    **双亲委派模型**的工作过程如下：

    当类加载器收到类的加载请求时，首先不会自己去加载这个类，而是会把这个请求委派给父类加载器去完成。每个层次的类加载器都是这样的，所有的加载请求都会传送到顶层的启动类加载器，只有父类加载器无法完成时，才会交给子加载器去完成。

    ![双亲委派模型的过程](https://i.loli.net/2021/01/07/PWeOThwsN7BSRck.png)

    双亲委派模型遵循三个原则：

    * 「委托性原则」：当子类加载器收到类的加载请求时，会将加载请求向上委托给父类加载器。
    * 「可见性原则」：允许子类加载器查看父类加载器加载的所有类，但是父类加载器不能查看子类加载器加载的类。
    * 「唯一性原则」：双亲委派的机制保证了Java类的唯一性。比如写了一个和JRE核心类同名的Object类，这时候双亲委派机制就会发挥作用了，避免自定义的类覆盖核心类。它会首先将加载类的请求，委托给Application ClassLoader去加载，再被其委托给Extension ClassLoader去加载，再被委托给BootStrap ClassLoader。因为启动类加载器发现已经加载了核心类Object类，就不会再去加载自定义的Object类。

4. 能举例子说明一下多态吗

    Java的多态主要是指在运行时才知道调用哪个方法而不是编译时就能得知的一种机制。

    方法的**重载**和**重写**就是典型的Java多态性的不同变现。重写是父类与子类的多态表现，重载是一个类的多态的表现。

5. 泛型的类型擦除

    如果一个方法接收`List<Object>`作为形参，而如果传递`List<String>`进去作为实参，是无法通过编译的，尽管String是Object的子类。